#+PROPERTY: header-args:elisp :tangle (concat temporary-file-directory "xandeer-tools-ivy.el")

* Header                                                 :noexport:

#+begin_src elisp
  ;;; xandeer-tools-ivy.el --- Xandeer's Emacs Configuration tools ivy file.  -*- lexical-binding: t; -*-

  ;; Copyright (C) 2020  Xandeer

  ;;; Commentary:

  ;; Xandeer's Emacs Configuration Editor Ivy.

  ;;; Code:
#+end_src

* Autoloads
:PROPERTIES:
:header-args: elisp :tangle (concat temporary-file-directory "xandeer-tools-ivy-function.el")
:END:

#+begin_src elisp :exports none
  ;;; xandeer-tools-ivy-function.el -*- lexical-binding: t; -*-

  ;; Copyright (C) 2020  Xandeer

  ;;; Commentary:

  ;; Xandeer's Emacs Configuration Company Mode.

  ;;; Code:
#+end_src

Some of them borrowed from doom-emacs

#+begin_src elisp
    ;;;###autoload
    (defun xandeer/ivy-is-workspace-buffer-p (buffer)
      (let ((buffer (car buffer)))
        (when (stringp buffer)
         (setq buffer (get-buffer buffer)))
        (xandeer/workspace-contains-buffer-p buffer)))

    ;;;###autoload
    (defun xandeer/ivy-is-workspace-other-buffer-p (buffer)
      (let ((buffer (car buffer)))
        (when (stringp buffer)
         (setq buffer (get-buffer buffer)))
        (and (not (eq buffer (current-buffer)))
           (xandeer/workspace-contains-buffer-p buffer))))

    ;;
    ;; Library
    ;;;###autoload
    (defun xandeer/ivy/switch-buffer-preview ()
      (let (ivy-use-virtual-buffers ivy--virtual-buffers)
        (counsel--switch-buffer-update-fn)))

    ;;;###autoload
    (defalias 'xandeer/ivy/switch-buffer-preview-all #'counsel--switch-buffer-update-fn)
    ;;;###autoload
    (defalias 'xandeer/ivy/switch-buffer-unwind      #'counsel--switch-buffer-unwind)

    ;;;###autoload
    (defun xandeer/ivy--switch-buffer (workspace other)
      (let ((current (not other))
            prompt action filter update unwind)
        (cond ((and workspace current)
               (setq prompt "Switch to workspace buffer: "
                     action #'ivy--switch-buffer-action
                     filter #'xandeer/ivy-is-workspace-other-buffer-p))
              (workspace
               (setq prompt "Switch to workspace buffer in other window: "
                     action #'ivy--switch-buffer-other-window-action
                     filter #'xandeer/ivy-is-workspace-buffer-p))
              (current
               (setq prompt "Switch to buffer: "
                     action #'ivy--switch-buffer-action))
              ((setq prompt "Switch to buffer in other window: "
                     action #'ivy--switch-buffer-other-window-action)))
        (when xandeer/ivy-buffer-preview
          (cond ((not (and ivy-use-virtual-buffers
                        (eq xandeer/ivy-buffer-preview 'everything)))
                 (setq update #'xandeer/ivy/switch-buffer-preview
                       unwind #'xandeer/ivy/switch-buffer-unwind))
                ((setq update #'xandeer/ivy/switch-buffer-preview-all
                       unwind #'xandeer/ivy/switch-buffer-unwind))))
        (ivy-read prompt 'internal-complete-buffer
                  :action action
                  :predicate filter
                  :update-fn update
                  :unwind unwind
                  :preselect (buffer-name (other-buffer (current-buffer)))
                  :matcher #'ivy--switch-buffer-matcher
                  :keymap ivy-switch-buffer-map
                  ;; NOTE A clever disguise, needed for virtual buffers.
                  :caller #'ivy-switch-buffer)))

    ;;;###autoload
    (defun xandeer/ivy/switch-workspace-buffer (&optional arg)
      "Switch to another buffer within the current workspace.
    If ARG (universal argument), open selection in other-window."
      (interactive "P")
      (xandeer/ivy--switch-buffer t arg))

    ;;;###autoload
    (defun xandeer/ivy/switch-workspace-buffer-other-window ()
      "Switch another window to a buffer within the current workspace."
      (interactive)
      (xandeer/ivy--switch-buffer t t))

    ;;;###autoload
    (defun xandeer/ivy/switch-buffer ()
      "Switch to another buffer."
      (interactive)
      (xandeer/ivy--switch-buffer nil nil))

    ;;;###autoload
    (defun xandeer/ivy/switch-buffer-other-window ()
      "Switch to another buffer in another window."
      (interactive)
      (xandeer/ivy--switch-buffer nil t))

    ;;;###autoload
    (defun xandeer/ivy-woccur ()
      "Invoke a wgrep buffer on the current ivy results, if supported."
      (interactive)
      (unless (window-minibuffer-p)
        (user-error "No completion session is active"))
      (require 'wgrep)
      (let ((caller (ivy-state-caller ivy-last)))
        (if-let (occur-fn (plist-get xandeer/ivy-edit-functions caller))
          (ivy-exit-with-action
           (lambda (_) (funcall occur-fn)))
         (if-let (occur-fn (plist-get ivy--occurs-list caller))
             (let ((buffer (generate-new-buffer
                            (format "*ivy-occur%s \"%s\"*"
                                    (if caller (concat " " (prin1-to-string caller)) "")
                                    ivy-text))))
               (with-current-buffer buffer
                 (let ((inhibit-read-only t))
                   (erase-buffer)
                   (funcall occur-fn))
                 (setf (ivy-state-text ivy-last) ivy-text)
                 (setq ivy-occur-last ivy-last)
                 (setq-local ivy--directory ivy--directory))
               (ivy-exit-with-action
                `(lambda (_)
                   (pop-to-buffer ,buffer)
                   (ivy-wgrep-change-to-wgrep-mode))))
           (user-error "%S doesn't support wgrep" caller)))))

    ;;;###autoload
    (defun xandeer/ivy-yas-prompt (prompt choices &optional display-fn)
      (yas-completing-prompt prompt choices display-fn #'ivy-completing-read))

    ;;;###autoload
    (defun xandeer/ivy-git-grep-other-window-action (x)
      "Opens the current candidate in another window."
      (when (string-match "\\`\\(.*?\\):\\([0-9]+\\):\\(.*\\)\\'" x)
        (select-window
         (with-ivy-window
          (let ((file-name   (match-string-no-properties 1 x))
                (line-number (match-string-no-properties 2 x)))
            (find-file-other-window (expand-file-name file-name (ivy-state-directory ivy-last)))
            (goto-char (point-min))
            (forward-line (1- (string-to-number line-number)))
            (re-search-forward (ivy--regex ivy-text t) (line-end-position) t)
            (run-hooks 'counsel-grep-post-action-hook)
            (selected-window))))))

    ;;;###autoload
    (defun xandeer/ivy-confirm-delete-file (x)
      (dired-delete-file x 'confirm-each-subdirectory))


    ;;
    ;;; File searching

    ;;;###autoload
    (defun xandeer/ivy/projectile-find-file ()
      "A more sensible `counsel-projectile-find-file', which will revert to
    `counsel-find-file' if invoked from $HOME, `counsel-file-jump' if invoked from a
    non-project, `projectile-find-file' if in a big project (more than
    `ivy-sort-max-size' files), or `counsel-projectile-find-file' otherwise.
    The point of this is to avoid Emacs locking up indexing massive file trees."
      (interactive)
      ;; Spoof the command so that ivy/counsel will display the (well fleshed-out)
      ;; actions list for `counsel-find-file' on C-o. The actions list for the other
      ;; commands aren't as well configured or are empty.
      (let ((this-command 'counsel-find-file))
        (call-interactively
         (cond ((or (file-equal-p default-directory "~")
                  (when-let (proot (xandeer/project-root))
                    (file-equal-p proot "~")))
                #'counsel-find-file)

             ((xandeer/project-p)
              (let ((files (projectile-current-project-files)))
                (if (<= (length files) ivy-sort-max-size)
                    #'counsel-projectile-find-file
                  #'projectile-find-file)))

             (#'counsel-file-jump)))))

    ;;;###autoload
    (cl-defun xandeer/ivy-file-search (&key query in all-files (recursive t) prompt args)
      "Conduct a file search using ripgrep.
    :query STRING
      Determines the initial input to search for.
    :in PATH
      Sets what directory to base the search out of. Defaults to the current
      project's root.
    :recursive BOOL
      Whether or not to search files recursively from the base directory."
      (declare (indent defun))
      (unless (executable-find "rg")
        (user-error "Couldn't find ripgrep in your PATH"))
      (require 'counsel)
      (let* ((this-command 'counsel-rg)
             (project-root (or (xandeer/project-root) default-directory))
             (directory (or in project-root))
             (args (concat (if all-files " -uu")
                           (unless recursive " --maxdepth 1")
                           " "
                           (mapconcat #'shell-quote-argument args " "))))
        (setq deactivate-mark t)
        (counsel-rg
         (or query
           (when (xandeer/region-active-p)
             (replace-regexp-in-string
              "[! |]" (lambda (substr)
                        (cond ((and (string= substr " ")
                                  (not *ivy-fuzzy*))
                               "  ")
                              ((string= substr "|")
                               "\\\\\\\\|")
                              ((concat "\\\\" substr))))
              (rxt-quote-pcre (xandeer/thing-at-point-or-region)))))
         directory args
         (or prompt
           (format "rg%s [%s]: "
                   args
                   (cond ((equal directory default-directory)
                          "./")
                         ((equal directory project-root)
                          (projectile-project-name))
                         ((file-relative-name directory project-root))))))))

    ;;;###autoload
    (defun xandeer/ivy/project-search (&optional arg initial-query directory)
      "Performs a live project search from the project root using ripgrep.
    If ARG (universal argument), include all files, even hidden or compressed ones,
    in the search."
      (interactive "P")
      (xandeer/ivy-file-search :query initial-query :in directory :all-files arg))

    ;;;###autoload
    (defun xandeer/ivy/project-search-from-cwd (&optional arg initial-query)
      "Performs a project search recursively from the current directory.
    If ARG (universal argument), include all files, even hidden or compressed ones."
      (interactive "P")
      (xandeer/ivy/project-search arg initial-query default-directory))

  ;;;###autoload
  (defun xandeer/search-cwd (&optional arg)
    "Conduct a text search in files under the current folder.
  If prefix ARG is set, prompt for a directory to search from."
    (interactive "P")
    (let ((default-directory
            (if arg (counsel-read-directory-name "Search directory: ")
              default-directory)))
      (call-interactively #'xandeer/ivy/project-search-from-cwd)))

  ;;;###autoload
  (defun xandeer/search-other-cwd ()
    "Conduct a text search in another directory."
    (interactive)
    (xandeer/search-cwd 'other))


    ;;
    ;;; Wrappers around `counsel-compile'

    ;;;###autoload
    (defun xandeer/ivy/compile ()
      "Execute a compile command from the current buffer's directory."
      (interactive)
      (counsel-compile default-directory))

    ;;;###autoload
    (defun xandeer/ivy/project-compile ()
      "Execute a compile command from the current project's root."
      (interactive)
      (counsel-compile (projectile-project-root)))

    ;;;###autoload
    (defun xandeer/ivy/git-grep-other-window-action ()
      "Open the current counsel-{ag,rg,git-grep} candidate in other-window."
      (interactive)
      (ivy-set-action #'xandeer/ivy-git-grep-other-window-action)
      (setq ivy-exit 'done)
      (exit-minibuffer))
#+end_src

#+begin_src elisp :exports none
  (provide 'xandeer-tools-ivy-function)
  ;;; xandeer-tools-ivy-function.el ends here
#+end_src

* Config
#+begin_src elisp
  (defvar xandeer/ivy-buffer-preview 'everything
    "If non-nil, preview buffers while switching, à la `counsel-switch-buffer'.
  When nil, don't preview anything.
  When non-nil, preview non-virtual buffers.
  When 'everything, also preview virtual buffers")

  (defvar xandeer/ivy-buffer-unreal-face 'font-lock-comment-face
    "The face for unreal buffers in `ivy-switch-to-buffer'.")

  (defvar xandeer/ivy-edit-functions nil
    "A plist mapping ivy/counsel commands to commands that generate an editable
  results buffer.")
#+end_src

** ivy
#+begin_src elisp
  (straight-use-package 'ivy)
  (leaf ivy
    :hook after-init-hook
    :custom
    ((ivy-wrap                         . t)
     (ivy-auto-shrink-minibuffer-alist . '((t . nil)))
     (ivy-height                       . 15)
     (ivy-fixed-height-minibuffer      . nil)
     (projectile-completion-system     . 'ivy)
     ;; disable magic slash on non-match
     (ivy-magic-slash-non-match-action . nil)
     ;; don't show recent files in switch-buffer
     (ivy-use-virtual-buffers          . nil)
     ;; ...but if that ever changes, show their full path
     (ivy-virtual-abbreviate           . 'full)
     ;; don't quit minibuffer on delete-error
     (ivy-on-del-error-function        . #'ignore)
     ;; enable ability to select prompt (alternative to `ivy-immediate-done')
     (ivy-use-selectable-prompt        . t))
    :config
    ;; Highlight each ivy candidate including the following newline, so that it
    ;; extends to the right edge of the window
    (setf (alist-get 't ivy-format-functions-alist)
          #'ivy-format-function-line)

    (after-x 'yasnippet
      (add-hook 'yas-prompt-functions #'xandeer/ivy-yas-prompt)))
#+end_src

** ivy-xref
#+begin_src elisp
  (straight-use-package 'ivy-xref)
  (leaf ivy-xref
    :custom (xref-show-xrefs-function . #'ivy-xref-show-xrefs))
#+end_src

** counsel
#+begin_src elisp
  (straight-use-package 'counsel)
  (leaf counsel
    :custom
    (counsel-find-file-at-point         . t)
    ;; Don't use ^ as initial input. Set this here because `counsel' defines more
    ;; of its own, on top of the defaults.
    (ivy-initial-inputs-alist           . nil)
    ;; helpful
    (counsel-describe-function-function . #'helpful-callable)
    (counsel-describe-variable-function . #'helpful-variable)
    :bind
    (([remap apropos]                    . counsel-apropos)
     ([remap bookmark-jump]              . counsel-bookmark)
     ([remap describe-bindings]          . counsel-descbinds)
     ([remap describe-face]              . counsel-faces)
     ([remap describe-function]          . counsel-describe-function)
     ([remap describe-variable]          . counsel-describe-variable)
     ([remap execute-extended-command]   . counsel-M-x)
     ([remap find-file]                  . counsel-find-file)
     ([remap find-library]               . counsel-find-library)
     ([remap imenu]                      . counsel-imenu)
     ([remap info-lookup-symbol]         . counsel-info-lookup-symbol)
     ([remap load-theme]                 . counsel-load-theme)
     ([remap locate]                     . counsel-locate)
     ([remap org-set-tags-command]       . counsel-org-tag)
     ([remap recentf-open-files]         . counsel-recentf)
     ([remap set-variable]               . counsel-set-variable)
     ([remap swiper]                     . counsel-grep-or-swiper)
     ([remap unicode-chars-list-chars]   . counsel-unicode-char)
     ([remap yank-pop]                   . counsel-yank-pop))
    ("C-c x s" . xandeer/search-cwd)
    ("C-c x S" . xandeer/search-other-cwd)
    (:counsel-find-file-map
     ("C-h"  . counsel-up-directory)
     ("C-l" . counsel-down-directory))
    :config
    (setq counsel-rg-base-command
          '("rg" "--hidden" "-M" "240" "--with-filename" "--no-heading" "--line-number" "--color" "never" "%s"))
    ;; Record in jumplist when opening files via counsel-{ag,rg,pt,git-grep}
    ;; (add-hook 'counsel-grep-post-action-hook #'better-jumper-set-jump)
     (ivy-add-actions
      'counsel-rg ; also applies to `counsel-rg'
      '(("O" xandeer/ivy-git-grep-other-window-action "open in other window")))

    (after-x 'savehist
      ;; Persist `counsel-compile' history
      (add-to-list 'savehist-additional-variables 'counsel-compile-history))

    ;; `counsel-imenu' -- no sorting for imenu. Sort it by appearance in page.
    (add-to-list 'ivy-sort-functions-alist '(counsel-imenu))

    ;; `counsel-locate'
    (when *is-a-mac*
      ;; Use spotlight on mac by default since it doesn't need any additional setup
      (setq counsel-locate-cmd #'counsel-locate-cmd-mdfind))

    ;; `counsel-find-file'
    (setq counsel-find-file-ignore-regexp "\\(?:^[#.]\\)\\|\\(?:[#~]$\\)\\|\\(?:^Icon?\\)")

    ;; `counsel-search': use normal page for displaying results, so that we see
    ;; custom ddg themes (if one is set).
    (setf (nth 1 (alist-get 'ddg counsel-search-engines-alist))
          "https://duckduckgo.com/?q="))
#+end_src

** counsel-projectile
#+begin_src elisp
    (straight-use-package 'counsel-projectile)
    (leaf counsel-projectile
      :bind
      (([remap projectile-find-file]        . counsel-projectile-find-file)
       ([remap projectile-find-dir]         . counsel-projectile-find-dir)
       ([remap projectile-switch-to-buffer] . counsel-projectile-switch-to-buffer)
       ([remap projectile-grep]             . counsel-projectile-grep)
       ([remap projectile-ag]               . counsel-projectile-ag)
       ([remap persp-switch-to-buffer]      . counsel-projectile-find-file)
       ("C-c x ."                           . counsel-projectile-switch-to-buffer)
       ([remap projectile-switch-project]   . counsel-projectile-switch-project))
      :config
      (after-x 'prescient
        (gsetq counsel-projectile-sort-files t)))
#+end_src

** ivy-prescient
#+begin_src elisp
  (straight-use-package 'ivy-prescient)
  (leaf ivy-prescient
    :hook ivy-mode-hook
    :mode-hook (prescient-persist-mode 1)
    :custom
    (ivy-prescient-retain-classic-highlighting . t)
    :config
    (setq prescient-filter-method '(literal regexp initialism pinyin)))
#+end_src

** icons and rich

#+begin_src elisp
  (straight-use-package 'all-the-icons-ivy-rich)
  (leaf all-the-icons-ivy-rich
    :defvar xandeer/all-the-icons-ivy-rich-reload-p
    :custom
    (all-the-icons-ivy-rich-icon-size . 0.7)
    :init
    (all-the-icons-ivy-rich-mode 1)
    (setq xandeer/all-the-icons-ivy-rich-reload-p nil)
    (defun xandeer/ivy-rich-reload ()
      (if (and all-the-icons-ivy-rich-mode
              xandeer/all-the-icons-ivy-rich-reload-p)
          (advice-remove #'counsel-M-x #'xandeer/ivy-rich-reload)
        (all-the-icons-ivy-rich-reload)
        (setq xandeer/all-the-icons-ivy-rich-reload-p t)))
    (defun xandeer/all-the-icons-ivy-rich-align-icons ()
      "Set tab size to 1, to insert tabs as delimiters."
      (setq-local tab-width 2))
    :advice
    (:before counsel-M-x xandeer/ivy-rich-reload)
    (:override all-the-icons-ivy-rich-align-icons xandeer/all-the-icons-ivy-rich-align-icons))

  (straight-use-package 'ivy-rich)
  (leaf ivy-rich
    :init (ivy-rich-mode 1))
#+end_src

** ivy pinyin
#+begin_src elisp
  (straight-register-package
   '(pinyinlib :host github
               :repo "xlshiz/pinyinlib.el"))
  (straight-use-package 'pinyinlib)
  (leaf pinyinlib
    :require t
    :after ivy-prescient
    :commands pinyinlib-build-regexp-string
    :init
    (setq pinyinlib--simplified-char-table 'pinyinlib--simplified-xiaohe)
    (defun x/pinyin-regexp-helper (str)
      "Construct pinyin regexp for STR."
      (cond ((equal str "\\).*?\\(") "\\).*?\\(")
            (t (pinyinlib-build-regexp-string str t))))

    (defun x/pinyinlib-build-regexp-string (str)
      "Build a pinyin regexp sequence from STR."
      (cond ((equal str " ") "\\).*?\\(")
            ((equal str "") nil)
            (t str)))

    (defun pinyin-to-utf8 (str)
      "Convert STR to UTF-8."
      (cond ((equal 0 (length str)) nil)
            (t (concat
                "\\("
                (mapconcat
                 #'x/pinyinlib-build-regexp-string
                 (remove nil (mapcar #'x/pinyin-regexp-helper (split-string str "")))
                 "")
                "\\)"))))

    (defun prescient-filter-regexps (query &optional with-groups)
      "Convert QUERY to list of regexps.
  Each regexp must match the candidate in order for a candidate to
  match the QUERY.

  If WITH-GROUPS is non-nil, enclose the initials in initialisms
  with capture groups. If it is the symbol `all', additionally
  enclose literal substrings with capture groups."
      (mapcar
       (lambda (subquery)
         (string-join
          (cl-remove
           nil
           (mapcar
            (lambda (method)
              (pcase method
                (`literal
                 (prescient--with-group
                  (char-fold-to-regexp subquery)
                  (eq with-groups 'all)))
                (`initialism
                 (prescient--initials-regexp subquery with-groups))
                (`regexp
                 (ignore-errors
                   ;; Ignore regexp if it's malformed.
                   (string-match-p subquery "")
                   subquery))
                (`fuzzy
                 (prescient--fuzzy-regexp subquery with-groups))
                (`prefix
                 (prescient--prefix-regexp subquery with-groups))
                (`pinyin
                 (pinyin-to-utf8 subquery))))
            (pcase prescient-filter-method
              ;; We support `literal+initialism' for backwards
              ;; compatibility.
              (`literal+initialism '(literal initialism))
              ((and (pred listp) x) x)
              (x (list x))))
           :test #'eq)
          "\\|"))
       (prescient-split-query query))))
#+end_src
* Footer                                                 :noexport:

#+begin_src elisp
  (provide 'xandeer-tools-ivy)
  ;;; xandeer-tools-ivy.el ends here
#+end_src
